---
title: "Pattern Matching"
document: D1260R1
date: 2018-10-09
audience: Evolution
author:
  - name: Michael Park
    email: <mcypark@gmail.com>
---

# Introduction

As algebraic data types gain better support in C++ with facilities such as
`tuple` and `variant`, the importance of mechanisms to interact with them have
increased. While mechanisms such as `apply` and `visit` have been added, their
usage is quite complex and limited even for simple cases. Pattern matching is
a widely adopted mechanism across many programming languages to interact with
algebraic data types that can help greatly simplify C++. Examples of programming
languages include text-based languages such as SNOBOL back in the 1960s,
functional languages such as Haskell and OCaml, and "mainstream" languages such
as Scala, Swift, and Rust.

Inspired by P0095 [@P0095] --- which proposed pattern matching and
language-level variant simultaneously --- this paper explores a possible
direction for pattern matching only, and does not address language-level
variant design. This is in correspondence with a straw poll from Kona 2015,
which encouraged exploration of a full solution for pattern matching.
SF: 16, WF: 6, N: 5, WA: 1, SA: 0.

# Motivation and Scope

Virtually every program involves branching on some predicates applied to a value
and conditionally binding names to some of its components for use in subsequent
logic. Today, C++ provides two types of selection statements: the `if` statement
and the `switch` statement.

Since `switch` statements can only operate on a _single_ integral value and
`if` statements operate on an _arbitrarily_ complex boolean expression, there is
a significant gap between the two constructs even in inspection of
the "vocabulary types" provided by the standard library.

In C++17, structured binding declarations [@P0144] introduced the ability to
concisely bind names to components of `tuple`-like values. The proposed
direction of this paper aims to naturally extend this notion by performing
__structured inspection__ prior to forming the __structured bindings__ with
a third selection statement: the `inspect` statement. The goal of the `inspect`
statement is to bridge the gap between `switch` and `if` statements with
a __declarative__, __structured__, __cohesive__, and __composable__ mechanism.

\pagebreak

# Before/After Comparisons

## Matching Integrals

+------------------------------------------------+-------------------------------------------------+
| __Before__                                     | __After__                                       |
+================================================+=================================================+
| ```cpp                                         | ```cpp                                          |
| switch (x) {                                   | inspect (x) {                                   |
|   case 0: std::cout << "got zero"; break;      |   0: std::cout << "got zero";                   |
|   case 1: std::cout << "got one"; break;       |   1: std::cout << "got one";                    |
|   default: std::cout << "don't care";          |   _: std::cout << "don't care";                 |
| }                                              | }                                               |
| ```                                            | ```                                             |
+------------------------------------------------+-------------------------------------------------+

## Matching Strings

+--------------------------------------+---------------------------------------+
| __Before__                           | __After__                             |
+======================================+=======================================+
| ```cpp                               | ```cpp                                |
| if (s == "foo") {                    | inspect (s) {                         |
|   std::cout << "got foo";            |   "foo": std::cout << "got foo";      |
| } else if (s == "bar") {             |   "bar": std::cout << "got bar";      |
|   std::cout << "got bar";            |   _: std::cout << "don't care";       |
| } else {                             | }                                     |
|   std::cout << "don't care";         | ```                                   |
| }                                    |                                       |
| ```                                  |                                       |
+--------------------------------------+---------------------------------------+

## Matching Tuples

+--------------------------------------+---------------------------------------+
| __Before__                           | __After__                             |
+======================================+=======================================+
| ```cpp                               | ```cpp                                |
| auto&& [x, y] = p;                   | inspect (p) {                         |
| if (x == 0 && y == 0) {              |   [0, 0]: std::cout << "on origin";   |
|   std::cout << "on origin";          |   [0, y]: std::cout << "on y-axis";   |
| } else if (x == 0) {                 |   [x, 0]: std::cout << "on x-axis";   |
|   std::cout << "on y-axis";          |   [x, y]: std::cout << x << ',' << y; |
| } else if (y == 0) {                 | }                                     |
|   std::cout << "on x-axis";          | ```                                   |
| } else {                             |                                       |
|   std::cout << x << ',' << y;        |                                       |
| }                                    |                                       |
| ```                                  |                                       |
+--------------------------------------+---------------------------------------+

## Matching Variants

+------------------------------------------------+-------------------------------------------------+
| __Before__                                     | __After__                                       |
+================================================+=================================================+
| ```cpp                                         | ```cpp                                          |
| struct visitor {                               | inspect (v) {                                   |
|   void operator()(int i) const {               |   <int> i: strm << "got int: " << i;            |
|     os << "got int: " << i;                    |   <float> f: strm << "got float: " << f;        |
|   }                                            | }                                               |
|   void operator()(float f) const {             | ```                                             |
|     os << "got float: " << f;                  |                                                 |
|   }                                            |                                                 |
|   std::ostream& os;                            |                                                 |
| };                                             |                                                 |
| std::visit(visitor{strm}, v);                  |                                                 |
| ```                                            |                                                 |
+------------------------------------------------+-------------------------------------------------+

## Matching Polymorphic Types

```cpp
struct Shape { virtual ~Shape() = default; };
struct Circle : Shape { int radius; };
struct Rectangle : Shape { int width, height; };
```

+------------------------------------------------+-------------------------------------------------+
| __Before__                                     | __After__                                       |
+================================================+=================================================+
| ```cpp                                         | ```cpp                                          |
| virtual int Shape::get_area() const = 0;       | int get_area(const Shape& shape) {              |
|                                                |   inspect (shape) {                             |
| int Circle::get_area() const override {        |     (as<Circle> ? [r]): return 3.14 * r * r;    |
|   return 3.14 * radius * radius;               |     (as<Rectangle> ? [w, h]): return w * h;     |
| }                                              |   }                                             |
| int Rectangle::get_area() const override {     | }                                               |
|   return width * height;                       | ```                                             |
| }                                              |                                                 |
| ```                                            |                                                 |
+------------------------------------------------+-------------------------------------------------+

## Evaluating Expressions

```cpp
struct Expr;
struct Neg { std::shared_ptr<Expr> expr; };
struct Add { std::shared_ptr<Expr> lhs, rhs; };
struct Mul { std::shared_ptr<Expr> lhs, rhs; };
struct Expr : std::variant<int, Neg, Add, Mul> { using variant::variant; };

namespace std {
  template <>
  struct variant_size<Expr> : variant_size<Expr::variant> {};

  template <std::size_t I>
  struct variant_alternative<I, Expr> : variant_alternative<I, Expr::variant> {};
}
```

+--------------------------------------------+-------------------------------------------------+
| __Before__                                 | __After__                                       |
+============================================+=================================================+
| ```cpp                                     | ```cpp                                          |
| int eval(const Expr& expr) {               | int eval(const Expr& expr) {                    |
|   struct visitor {                         |   inspect (expr) {                              |
|     int operator()(int i) const {          |     <int> i: return i;                          |
|       return i;                            |     <Neg> [e]: return -eval(*e);                |
|     }                                      |     <Add> [l, r]: return eval(*l) + eval(*r);   |
|     int operator()(const Neg& n) const {   |     <Mul> [l, r]: return eval(*l) * eval(*r);   |
|       return -eval(*n.expr);               |   }                                             |
|     int operator()(const Add& a) const {   | }                                               |
|       return eval(*a.lhs) + eval(*a.rhs);  | ```                                             |
|     }                                      |                                                 |
|     int operator()(const Mul& m) const {   |                                                 |
|       return eval(*m.lhs) * eval(*m.rhs);  |                                                 |
|     }                                      |                                                 |
|   };                                       |                                                 |
|   return std::visit(visitor{}, expr);      |                                                 |
| }                                          |                                                 |
| ```                                        |                                                 |
+--------------------------------------------+-------------------------------------------------+

# Design Overview

## Basic Syntax

> | `inspect constexpr`_~opt~_ `(` _init-statement~opt~_ _condition_ `) {`
> |     _pattern_ _guard~opt~_ `:` _statement_
> |     _pattern_ _guard~opt~_ `:` _statement_
> |     ...
> | `}`

> | _guard:_
> |     `if (` _expression_ `)`

## Basic Model

Within the parentheses, the `inspect` statement is equivalent to `switch` and
`if` statements except that no conversion nor promotion takes place in
evaluating the value of its condition.

When the `inspect` statement is executed, its condition is evaluated and matched
in order (first match semantics) against each pattern. If a pattern successfully
matches the value of the condition and the boolean expression in the guard
evaluates to `true` (or if there is no guard at all), control is passed to the
statement following the matched pattern label. If the guard expression evaluates
to `false`, control flows to the subsequent pattern. If no pattern matches, none
of the statements are executed.

## Types of Patterns

### Primary Patterns

#### Wildcard Pattern

The wildcard pattern has the form:

> | `_`

and matches any value `v`.

```cpp
int v = /* ... */;

inspect (v) {
    _: std::cout << "ignored";
//  ^ wildcard pattern
}
```

[ _Note:_ Even though `_` is a valid identifier, it does not introduce a name. ]

#### Identifier Pattern

The identifier pattern has the form:

> | _identifier_

and matches any value `v`. The introduced name behaves as an lvalue
referring to `v`, and is in scope from its point of declaration until
the end of the statement following the pattern label.

```cpp
int v = /* ... */;

inspect (v) {
    x: std::cout << x;
//  ^ identifier pattern
}
```

[ _Note:_ If the identifier pattern is used as a top-level pattern,
          it has the same syntax as a `goto` label. ]

#### Constant Pattern

The constant pattern has the form:

> | _constant expression_

and matches value `v` if a call to member `c.match(v)` or else a non-member
ADL-only `match(c, v)` is contextually convertible to `bool` and evaluates to
`true` where `c` is the _constant expression_.

The following is the default definition of `match(x, y)`.

```cpp
template <typename T, typename U>
constexpr auto match(T&& lhs, U&& rhs)
    -> decltype(std::forward<T>(lhs) == std::forward<U>(rhs)) {
  return std::forward<T>(lhs) == std::forward<U>(rhs);
}
```

```cpp
int v = /* ... */;

inspect (v) {
    0: std::cout << "got zero";
    1: std::cout << "got one";
//  ^ constant pattern
}
```

[ _Note:_ `+id` or `(id)` is needed to disambiguate with the identifier pattern. ]

```cpp
static constexpr int zero = 0, one = 1;
int v = /* ... */;

inspect (v) {
    +zero: std::cout << "got zero";
    (one): std::cout << "got one";
//  ^^^^^ constant pattern
}
```

### Compound Patterns

#### Structured Binding Pattern

The structured binding pattern has the form:

> | `[` _pattern_~0~`,` _pattern_~1~`,` ...`,` _pattern_~N~ `]`

and matches value `v` if each _pattern~i~_ matches the _i_^th^ component of `v`.
The components of `v` are given by the structured binding declaration:
`auto&& [__e`~0~`, __e`~1~`,` ...`, __e`~N~`] = v;` where each `__e`_~i~_
are unique exposition-only identifiers.

```cpp
std::pair<int, int> p = /* ... */;

inspect (p) {
    [0, 0]: std::cout << "on origin";
    [0, y]: std::cout << "on y-axis";
//      ^ identifier pattern
    [x, 0]: std::cout << "on x-axis";
//      ^ constant pattern
    [x, y]: std::cout << x << ',' << y;
//  ^^^^^^ structured binding pattern
}
```

#### Alternative Pattern

The alternative pattern has the form:

> | `< auto >` _pattern_
> | `<` _concept_ `>` _pattern_
> | `<` _type_ `>` _pattern_
> | `<` _constant expression_ `>` _pattern_

Let `v` be the value being matched and `V` be `std::remove_cvref_t<decltype(v)>`.\newline
Let `Alt` be the entity inside the angle brackets.

If `std::variant_size_v<V>` is well-formed and evaluates to an integral,
the alternative pattern matches `v` if `Alt` is compatible with the current
index of `v` and _pattern_ matches the active alternative of `v`.

Let `I` be the current index of `v` given by a member `v.index()` or else
a non-member ADL-only `index(v)`. The active alternative of `v` is given by
`std::variant_alternative_t<I, V>&` initialized by a member `v.get<I>()` or
else a non-member ADL-only `get<I>(v)`.

`Alt` is compatible with `I` if one of the following four cases is true:

  - `Alt` is `auto`
  - `Alt` is a _concept_ and `std::variant_alternative_t<I, V>` satisfies the _concept_.
  - `Alt` is a _type_ and `std::is_same_v<Alt, std::variant_alternative_t<I, V>>` is `true`
  - `Alt` is a _constant expression_ that can be used in a `switch` and is the same value as `I`.

+-----------------------------------------------------+----------------------------------------------+
| __Before__                                          | __After__                                    |
+=====================================================+==============================================+
| ```cpp                                              | ```cpp                                       |
| std::visit([&](auto&& x) {                          | inspect (v) {                                |
|   strm << "got auto: " << x;                        |   <auto> x: strm << "got auto: " << x;       |
| }, v);                                              | }                                            |
| ```                                                 | ```                                          |
+-----------------------------------------------------+----------------------------------------------+
| ```cpp                                              | ```cpp                                       |
| std::visit([&](auto&& x) {                          | inspect (v) {                                |
|   using X = std::remove_cvref_t<decltype(x)>;       |   <C1> c1: strm << "got C1: " << c1;         |
|   if constexpr (C1<X>()) {                          |   <C2> c2: strm << "got C2: " << c2;         |
|     strm << "got C1: " << x;                        | }                                            |
|   } else if constexpr (C2<X>()) {                   | ```                                          |
|     strm << "got C2: " << x;                        |                                              |
|   }                                                 |                                              |
| }, v);                                              |                                              |
| ```                                                 |                                              |
+-----------------------------------------------------+----------------------------------------------+
| ```cpp                                              | ```cpp                                       |
| std::visit([&](auto&& x) {                          | inspect (v) {                                |
|   using X = std::remove_cvref_t<decltype(x)>;       |   <int> i: strm << "got int: " << i;         |
|   if constexpr (std::is_same_v<int, X>) {           |   <float> f: strm << "got float: " << f;     |
|     strm << "got int: " << x;                       | }                                            |
|   } else if constexpr (                             | ```                                          |
|       std::is_same_v<float, X>) {                   |                                              |
|     strm << "got float: " << x;                     |                                              |
|   }                                                 |                                              |
| }, v);                                              |                                              |
| ```                                                 |                                              |
+-----------------------------------------------------+----------------------------------------------+
| ```cpp                                              | ```cpp                                       |
| std::variant<int, int> v = /* ... */;               | std::variant<int, int> v = /* ... */;        |
|                                                     |                                              |
| std::visit([&](int x) {                             | inspect (v) {                                |
|   strm << "got int: " << x;                         |   <int> x: strm << "got int: " << x;         |
| }, v);                                              | }                                            |
| ```                                                 | ```                                          |
+-----------------------------------------------------+----------------------------------------------+
| ```cpp                                              | ```cpp                                       |
| std::variant<int, int> v = /* ... */;               | std::variant<int, int> v = /* ... */;        |
|                                                     |                                              |
| std::visit([&](auto&& x) {                          | inspect (v) {                                |
|   switch (v.index()) {                              |   <0> x: strm << "got first: " << x;         |
|     case 0: {                                       |   <1> x: strm << "got second: " << x;        |
|       strm << "got first: " << x;                   | }                                            |
|       break;                                        | ```                                          |
|     }                                               |                                              |
|     case 1: {                                       |                                              |
|       strm << "got second: " << x;                  |                                              |
|       break;                                        |                                              |
|     }                                               |                                              |
|   }                                                 |                                              |
| }, v);                                              |                                              |
| ```                                                 |                                              |
+-----------------------------------------------------+----------------------------------------------+

#### Binding Pattern

The binding pattern has the form:

> | _identifier_ @ _pattern_

and matches value `v` if _pattern_ matches it. The introduced name behaves as
an lvalue referring to `v`, and is in scope from its point of declaration until
the end of the statement following the pattern label.

```cpp
std::variant<Point, /* ... */> v = /* ... */;

inspect (v) {
    <Point> p @ [x, y]: // ...
//          ^^^^^^^^^^ binding pattern
}
```

#### Extractor Pattern

The extractor pattern has the form:

> | `(` _constant expression_ `?` _pattern_ `)`

Let `e` be the result of a call to member `c.extract(v)` or else a non-member
ADL-only `extract(c, v)` where `c` is the _constant expression_.

The extractor pattern matches value `v` if `e` is contextually convertible to
`bool` and evaluates to `true` and _pattern_ matches `*e`.

```cpp
struct {
    std::optional<std::array<std::string_view, 2>> extract(std::string_view sv) const;
} email;

struct {
    std::optional<std::array<std::string_view, 3>> extract(std::string_view sv) const;
} phone_number;

inspect (s) {
    (email ? [address, domain]): std::cout << "got an email";
    (phone_number ? ["415", _, _]): std::cout << "got a phone number";
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ extractor pattern
}
```

#### As Pattern

The as pattern is a special instance of the extractor pattern, and behaves as:

```cpp
template <typename Derived>
struct As {
    template <typename Base>
    auto* extract(Base& base) const {
        static_assert(std::is_polymophic_v<Base>);
        static_assert(std::is_convertible_v<Derived*, Base*>,
                      "cross-casts are not allowed.");
        using R = /* `Derived` with the same _cv_-qualification as `Base` */;
        return dynamic_cast<R*>(&base);
    }
};

template <typename Derived>
inline constexpr As<Derived> as;
```

While this is a possible library implementation, it will likely benefit from
being implemented as a compiler intrinsic for optimization opportunities.

N3449 [@N3449] describes techniques involving vtable pointer caching and
hash conflict minimization that are implemented in the Mach7 [@Mach7] library,
but also mentions further opportunities available for a compiler solution.

Given the following definition of a `Shape` class hierarchy:

```cpp
struct Shape { virtual ~Shape() = default; };

struct Circle : Shape { int radius; };
struct Rectangle : Shape { int width, height; };
```

+------------------------------------------------+-------------------------------------------------+
| __Before__                                     | __After__                                       |
+================================================+=================================================+
| ```cpp                                         | ```cpp                                          |
| virtual int Shape::get_area() const = 0;       | int get_area(const Shape& shape) {              |
|                                                |   inspect (shape) {                             |
| int Circle::get_area() const override {        |     (as<Circle> ? [r]): return 3.14 * r * r;    |
|   return 3.14 * radius * radius;               |     (as<Rectangle> ? [w, h]): return w * h;     |
| }                                              | //  ^^^^^^^^^^^^^^^^^^^^^^^ as pattern          |
|                                                |   }                                             |
| int Rectangle::get_area() const override {     | }                                               |
|   return width * height;                       | ```                                             |
| }                                              |                                                 |
| ```                                            |                                                 |
+------------------------------------------------+-------------------------------------------------+

## Pattern Guard

The pattern guard has the form:

> | `if (` _expression_ `)`

Let `e` be the result of _expression_ contextually converted to `bool`.
If `e` is `true`, control is passed to the corresponding statement.
Otherwise, control flows to the subsequent pattern.

The pattern guard allows to perform complex tests that cannot be performed
within the _pattern_. For example, performing tests across multiple bindings:

```cpp
inspect (p) {
    [x, y] if test(x, y): std::cout << x << ',' << y << " passed";
//         ^^^^^^^^^^^^^ pattern guard
}
```

This also diminishes the desire for fall-through semantics within the
statements, an unpopular feature even in `switch` statements.
For the reified semantics of the pattern guard, consider the following snippet:

```cpp
switch (x) {
    case c1: if (cond1) { stmt1; break; } [[fallthrough]]
    case c2: if (cond2) { stmt2; break; } [[fallthrough]]
}
```

## `inspect constexpr`

Note that every _pattern_ is able to determine whether
it matches value `v` as a boolean expression in isolation.

Let `matches` be the condition for which a _pattern_ matches a value `v`.
Ignoring any potential optimization opportunities, we're able to perform the
following transformation:

+--------------------------------------+-----------------------------------------------------------+
| __`inspect`__                        | __`if`__                                                  |
+======================================+===========================================================+
| ```cpp                               | ```cpp                                                    |
| inspect (v) {                        | if (pattern1 matches v && cond1) stmt1                    |
|   pattern1 if (cond1): stmt1         | else if (pattern2 matches v) stmt2                        |
|   pattern2: stmt2                    | // ...                                                    |
|   // ...                             | ```                                                       |
| }                                    |                                                           |
| ```                                  |                                                           |
+--------------------------------------+-----------------------------------------------------------+

`inspect constexpr` is then formulated by applying `constexpr` to every `if` branch.

+--------------------------------------+-----------------------------------------------------------+
| __`inspect constexpr`__              | __`if constexpr`__                                        |
+======================================+===========================================================+
| ```cpp                               | ```cpp                                                    |
| inspect constexpr (v) {              | if constexpr (pattern1 matches v && cond1) stmt1          |
|   pattern1 if (cond1): stmt1         | else if constexpr (pattern2 matches v) stmt2              |
|   pattern2: stmt2                    | // ...                                                    |
|   // ...                             | ```                                                       |
| }                                    |                                                           |
| ```                                  |                                                           |
+--------------------------------------+-----------------------------------------------------------+

## Exhaustiveness Checking

The `inspect` statement can be declared with the `[[exhaustive]]`
attribute to request for implementation-defined exhaustiveness checking.

# Proposed Wording

The following is the beginning of an attempt at a syntactic structure.

Add to __\S8.4 [stmt.select]__ of ...

\pnum{1}Selection statements choose one of several flows of control.

> | _selection-statement:_
> |     `if constexpr`_~opt~_ `(` _init-statement~opt~_ _condition_ `)` _statement_
> |     `if constexpr`_~opt~_ `(` _init-statement~opt~_ _condition_ `)` _statement_ `else` _statement_
> |     `switch (` _init-statement~opt~_ _condition_ `)` _statement_
> |     \added `inspect constexpr`_~opt~_ `(` _init-statement~opt~_ _condition_ `) {` _inspect-case-seq_ `}`\unchanged
>
> \added
> | _inspect-case-seq:_
> |     _inspect-case_
> |     _inspect-case-seq_ _inspect-case_
>
> | _inspect-case:_
> |     _attribute-specifier-seq~opt~_ _inspect-pattern_ _inspect-guard~opt~_ `:` _statement_
>
> | _inspect-pattern:_
> |     _wildcard-pattern_
> |     _identifier-pattern_
> |     _constant-pattern_
> |     _structured-binding-pattern_
> |     _alternative-pattern_
> |     _binding-pattern_
> |     _extractor-pattern_
>
> | _inspect-guard:_
> |     `if (` _expression_ `)`
> \unchanged

# Design Decisions

## Extending Structured Bindings Declaration

The design is intended to be consistent and to naturally extend the notions
introduced by structured bindings. That is, The subobjects are __referred__
to rather than being assigned into new variables.

## `inspect` rather than `switch`

This proposal introduces a new `inspect` statement rather than trying to extend
the `switch` statement. P0095R0 [@P0095R0] had proposed extending `switch`
and received feedback to "leave `switch` alone" in Kona 2015.

The following are some of the reasons considered:

  - `switch` allows the `case` labels to appear __anywhere__, which hinders
    the goal of pattern matching in providing __structured__ inspection.
  - The fall-through semantics of `switch` generally results in `break` being
    attached to every case, and is known to be error-prone.
  - `switch` is purposely restricted to integrals for __guaranteed__ efficiency.
    The primary goal of pattern matching in this paper is expressiveness while
    being at least as efficient as the naively hand-written code.

## First Match rather than Best Match

The proposed matching algorithm has first match semantics. The choice of first
match is mainly due to complexity. Our overload resolution rules for function
declarations are extremely complex and is often a mystery.

Best match via overload resolution for function declarations are absolutely
necessary due to the non-local and unordered nature of declarations.
That is, function declarations live in different files and get pulled in
via mechanisms such as `#include` and `using` declarations, and there is no
defined order of declarations like Haskell does, for example. If function
dispatching depended on the order of `#include` and/or `using` declarations
being pulled in from hundreds of files, it would be a complete disaster.

Pattern matching on the other hand do not have this problem because
the construct is local and ordered in nature. That is, all of the candidate
patterns appear locally within `inspect (x) { /* ... */ }` which cannot span
across multiple files, and appear in a specified order. Note that this is
consistent with `try`/`catch` for the same reasons: locality and order.

Consider also the amount of limitations we face in overload resolution due
to the opacity of user-defined types. `T*` is related to `unique_ptr<T>` as
it is to `vector<T>` as far as the type system is concerned. This limitation
will likely be even bigger in a pattern matching context with the amount of
customization points available for user-defined behavior.

## Statement rather than Expression

This paper diverges from P0095 [@P0095] in that it proposes to add `inspect` as
a statement only rather than trying to double as a statement and an expression.
The main reason here is that the semantic differences between the statement and
expression forms are not trivial.

  - In the situation where none of the cases match, the statement form simply
    skips over the entire statement à la `switch`, whereas the expression form
    throws an exception since it is required to yield a value.
  - Resulting type of the statement form of `inspect` within an
    "immediately-invoked-lambda" is required to be explicitly specified, or
    is determined by the first `return` statement. In contrast, the expression
    form will probably need to use `std::common_type_t<Ts...>` where `Ts...` are
    types of `N` expressions to be consistent with the ternary operator.

While an expression form of `inspect` would be useful, the author believes that
it can and should be introduced later, with different enough syntax such as
`x inspect { p1 => e1, p2 => e2 }`. The proposed syntax of the `inspect`
statement in this paper consistent with every other statement in C++ today.

## Language rather than Library

There are three popular pattern matching libraries for C++ today:
Mach7 [@Mach7], MPark.Patterns [@Patterns], and simple_match [@SimpleMatch].

While the libraries have been useful for gaining experience with
implementation and cleaner interfaces, the issue of introducing identifiers,
syntactic overhead of the patterns, and the reduced optimization opportunities
justify support as a language feature from a usability standpoint.

## Optimizations

The following are few of the optimizations that are worth noting.

### Structured Binding Pattern

Structured binding patterns can be optimized by performing `switch` over
the columns with the duplicates removed, rather than the naive approach of
performing a comparison per element. This removes unnecessary duplicate
comparisons that would be performed otherwise. This would likely require some
wording around "comparison elision" in order to enable such optimizations.

### Alternative Pattern

The sequence of alternative patterns can be executed in a `switch`.

### Open Class Hierarchy

N3449 [@N3449] describes techniques involving vtable pointer caching and
hash conflict minimization that are implemented in the Mach7 [@Mach7] library,
but also mentions further opportunities available for a compiler solution.

# Future Work

## Language Support for Variant

The design of this proposal also accounts for a potential language support
for variant. It achieves this by keeping the alternative pattern flexible
for new extensions via `<` _new_entity_ `>` _pattern_.

Consider an extension to `union` that allows it to be tagged by an integral,
and has proper lifetime management such that the active alternative need not
be destroyed manually.

```cpp
// `: type` specifies the type of the underlying tag value.
union U : int { char small[32]; std::vector<char> big; };
```

We could then allow `<` _qualified-id_ `>` that refers to a `union`
alternative to support pattern matching.

```cpp
U u = /* ... */;

inspect (u) {
  <U::small> s: std::cout << s;
  <U::big> b: std::cout << b;
}
```

The main point is that whatever entity is introduced as the discriminator,
the presented form of alternative pattern should be extendable to support it.

## Patterns in range-based `for` loop

```cpp
for (auto&& [0, y] : points) {
  // only operate on points on the y-axis.
}
```

Structured binding declaration is allowed in range-based `for` loop:

```cpp
for (auto&& [x, y] : points) { /* ... */ }
```

The `[x, y]` part can also be a pattern of an `inspect` statement rather than
a structured binding declaration.

+--------------------------------------+---------------------------------------+
| __Before__                           | __After__                             |
+======================================+=======================================+
| ```cpp                               | ```cpp                                |
| for (auto&& p : points) {            | for (auto&& p : points) {             |
|   auto&& [x, y] = p;                 |   inspect (p) {                       |
|   // ...                             |     [x, y]: // ...                    |
| }                                    |   }                                   |
| ```                                  | }                                     |
|                                      | ```                                   |
+--------------------------------------+---------------------------------------+

With this model, allowing patterns directly in range-based `for` loop becomes natural.

+--------------------------------------+---------------------------------------+
| __Code__                             | __Expanded__                          |
+======================================+=======================================+
| ```cpp                               | ```cpp                                |
| for (auto&& [0, y] : points) {       | for (auto&& p : points) {             |
|   // only points on the y-axis.      |   inspect (p) {                       |
| }                                    |     [0, y]: // ...                    |
| ```                                  |   }                                   |
|                                      |   // falls through if no match        |
|                                      | }                                     |
|                                      | ```                                   |
+--------------------------------------+---------------------------------------+

## Note on Ranges

The benefit of pattern matching for ranges is unclear. While it's possible to
come up with a ranges pattern, e.g., `{x, y, z}` to match against a fixed-size
range, it's not clear whether there is a worthwhile benefit.

The typical pattern found in functional languages of matching a range on
head and tail doesn't seem to be all that common or useful in C++ since
ranges are generally handled via loops rather than recursion.

Ranges likely will be best served by the range adaptors / algorithms,
but further investigation is needed.

# Acknowledgements

Thank you to Agustín Bergé, Ori Bernstein, Alexander Chow, Louis Dionne,
Matt Calabrese, Michał Dominiak, Eric Fiselier, Zach Laine, Jason Lucas,
David Sankel, Tony Van Eerd, and everyone else who contributed to
the discussions, and encouraged me to write this paper.

---
references:
  - id: N3449
    title: "Open and Efficient Type Switch for C++"
    issued:
      year: 2012
      month: 9
    author:
      family: Stroustrup
      given: Bjarne
    container-title: N3449
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3449.pdf
  - id: N3627
    title: "Relaxed switch statement"
    issued:
      year: 2013
      month: 2
    author:
      family: Yuan
      given: Zhihao
    container-title: N3627
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3627.html
  - id: P0095R0
    title: "Pattern Matching and Language Variants"
    issued:
      year: 2015
      month: 9
    author:
      family: Sankel
      given: David
    container-title: P0095R0
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0095r0.html
  - id: P0095
    title: "Pattern Matching and Language Variants"
    issued:
      year: 2016
      month: 5
    author:
      family: Sankel
      given: David
    container-title: P0095R1
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0095r1.html
  - id: P0144
    title: "Structured bindings"
    issued:
      year: 2016
      month: 3
    author:
      - family: Sutter
        given: Herb
      - family: Stroustrup
        given: Bjarne
      - family: Dos Reis
        given: Gabriel
    container-title: P0144
    URL: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0144r2.pdf
  - id: Mach7
    title: "Mach7: Pattern Matching for C++"
    author:
      - family: Solodkyy
        given: Yuriy
      - family: Dos Reis
        given: Gabriel
      - family: Stroustrup
        given: Bjarne
    container-title: Mach7
    URL: https://github.com/solodon4/Mach7
  - id: SimpleMatch
    title: "Simple, Extensible C++ Pattern Matching Library"
    author:
      - family: Bandela
        given: John
    container-title: simple_match
    URL: https://github.com/jbandela/simple_match
  - id: Patterns
    title: "Pattern Matching in C++"
    author:
      - family: Park
        given: Michael
    container-title: MPark.Patterns
    URL: https://github.com/mpark/patterns
---

<!--
# Other Languages and Libraries
## C\#
## Rust
Constants: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md
### Intersection of semantic / structural equality
## Scala
Scala Tutorial - Pattern Matching: https://www.youtube.com/watch?v=ULcpWn23waw
Matching Objects with Patterns: https://infoscience.epfl.ch/record/98468/files/MatchingObjectsWithPatterns-TR.pdf
### Extractors
## F\#
### Active Patterns
From F# to Scala Extractors: https://theburningmonk.com/2017/01/from-f-to-scala-extractors/

# Examples

## "Closed" Class Hierarchy

A class hierarchy can effectively be closed with an `enum` that maintains
the list of its members, and provide efficient dispatching by opting into
the Variant-Like protocol.

```cpp
struct Shape {
  enum Kind { Circle, Rectangle } kind;

  Kind index() const { return kind; }

  template <Kind K>
  auto&& get() const {
    return static_cast<const std::variant_alternative_t<K, Shape>&>(*this);
  }
};

struct Circle : Shape {
  Circle(int radius) : Shape{Shape::Kind::Circle}, radius(radius) {}

  int radius;
};

struct Rectangle : Shape {
  Rectangle(int width, int height)
    : Shape{Shape::Kind::Rectangle}, width(width), height(height) {}

  int width, height;
};

namespace std {
  template <>
  struct variant_size<Shape> : std::integral_constant<std::size_t, 2> {};

  template <>
  struct variant_alternative<Shape::Circle, Shape> { using type = Circle; };

  template <>
  struct variant_alternative<Shape::Rectangle, Shape> { using type = Rectangle; };
}

int get_area(const Shape& shape) {
  inspect (shape) {
    <Circle> c: return 3.14 * c.radius * c.radius;
    <Rectangle> r: return r.width * r.height;
  }
  // switch (shape.index()) {
  //   using Index = decltype(shape.index());
  //   case (Index)0: {
  //     const std::variant_alternative_t<(Index)0, Shape>& c =
  //         shape.template get<(Index)0>();
  //     return 3.14 * c.radius * c.radius;
  //     break;
  //   }
  //   case (Index)1: {
  //     const std::variant_alternative_t<(Index)1, Shape>& r =
  //         shape.template get<(Index)1>();
  //     return r.width * r.height;
  //     break;
  //   }
  // }
}
```
-->
